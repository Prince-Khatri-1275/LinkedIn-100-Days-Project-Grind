# DFS

## DFS as Path Finding Algorithm the solver

$ Make an stack with start as its element
stack = [start]

$ Loop steps
    $ Pop the stack i.e. take last element of the stack
    currentTile = pop(stack)

    $ Add currentTile to visited set/list

    $ If currentTile is goal return its path
    if isGoal(currentTile) ret path2node(currentTile)

    $ Else add every one of its unvisited children or neighbor to stack
    for neigh in neighs(currentTile) if neigh not in visited append to stack

## DFS as a Maze Generating Algorithm

$ start with a randomly selected tile
start = random(tile from tiles)

stack = [start]

$ Loop starts

    $ Pop the stack
    currentTile = stack.open() $ fuga stack

    $ Add currentTile into visited
    currentTile -> visited

    $ Adding new unvisited neighbors to the stack with updating neighbors( Here I was confused but I remembered our sync_neighbor function will work wonders for this so let's handle this later with that ok )

    neigh <= neighbor : (currentTile) if new unvisited
    sync at end or with a tweak in stack you will see soon 

    $ Now for the main thing when to stop :- 
    I think if tiles are visited then so a tile record set or maybe set difference between tiles values and our visited set kind of thing.